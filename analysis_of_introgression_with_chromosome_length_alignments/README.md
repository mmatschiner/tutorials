# Analysis of Introgression with Chromosome-Length Alignments

A tutorial on the analysis of hybridization and introgression with whole-chromosome alignments

## Summary

Phylogenetic approaches based on a large number of sequence alignments from across the genome can serve as a useful complement to SNP-based analyses for the detection of past introgression events. In contrast to SNP-based analyses such as the ABBA-BABA test, the use of sequence alignments permits the inference of local phylogenies when more than four species are included in the dataset. Introgression tests based on such sets of phylogenies can be robust to conditions that may produce misleading results in the ABBA-BABA test. In particular, the ABBA-BABA test assumes identical substitution rates for all species and the absence of homoplasies so that derived sites can only be shared if they had the same origin; independent substitutions at the same site are ignored. These conditions assumed by the ABBA-BABA test are likely to hold in sets of recently diverged species, but may be problematic when more divergent species are compared. In those cases, phylogenetic approaches can serve to verify or reject patterns of introgression determined with SNP-based methods.

On the other hand, the identification of suitable alignment blocks for phylogenetic inference across the genome can be difficult, for example when chromosome-length alignments were generated by read mapping to a distantly related reference species, a process that may result in a large proportion of missing data. One way to compensate for missing data is the use of sufficiently long alignment blocks for phylogenetic analyses, given that there is usually no shortage in overall sequence data in genomic studies. However, the use of long alignment blocks can also be problematic because the probability of within-block recombination, which violates the models of most phylogenetic approaches, increases with the length of the alignment block. To account for this, methods can be applied to identify recombination breakpoints and to filter the alignment blocks accordingly. The accuracy of these methods, however, so far remains questionable, and the consequences of undetected recombination have not been tested thoroughly. Despite these potential caveats, a growing number of phylogenomic studies uses time calibrated phylogenies based on long sequence alignments from aross the chromosome to detect introgression and the results of these studies indicate that the methodology works well in general.


## Table of contents

* [Outline](#outline)
* [Dataset](#dataset)
* [Requirements](#requirements)
* [Genotype phasing](#phasing)
* [Preparing a chromosome-length alignment](#preparing)
* [Identifying alignment blocks for phylogenetic analysis](#blocks)
* [Inferring block phylogenies with IQ-TREE](#iqtree)
* [Analyzing asymmetry of trio topologies](#asymmetry)
* [XXXtriangle](#triangle)
* [Simulating recombination with c-genie](#cgenie)


<a name="outline"></a>
## Outline

In this tutorial I am going to demonstrate how phylogenies from different regions of the genome can be used to infer past introgression events. The alignment blocks used for phylogenetic inference will be extracted from a phased chromosome-length alignment, and they will be filtered according to their proportion of missing data and their frequency of recombination breakpoints to identify the most suitable alignment blocks for phylogenetic analysis. This analysis will then be conducted for each selected alignment block based on maximum likelihood with IQ-TREE. The resulting set of local phylogenies will then be used to determine imbalance among alternative phylogenetic topologies for each species trio, and as with *D*-statistics in tutorial [Analysis of Introgression with SNP data](../analysis_of_introgression_with_snp_data/README.md), these imbalances will be visualized in the form of a heatmap. Additionally, particularly controversial phylogenetic relationships will be analyzed in more detail by plotting differences in likelihood support for competing topological hypotheses.


<a name="dataset"></a>
## Dataset

The dataset used in this tutorial will be a chromosome-length alignment with phased sequences for the same 14 cichlid species that were already used in tutorials [Species-Tree Inference with SNP Data](../species_tree_inference_with_snp_data/README.md) and [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md). As in these other tutorials, only data homologous to chromosome 5 of the tilapia (*Oreochromis niloticus*) genome assembly ([Conte et al. 2017](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-017-3723-5)) will be used to reduce the computational demand of the analyses. The phased chromosome-length alignment will be generated in the first part of this tutorial based on three different types of input: The VCF file [`NC_031969.f5.sub1.vcf.gz`](data/NC_031969.f5.sub1.vcf.gz) with phased SNP data produced in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md), the reference sequence for the chromosome from the tilapia assembly, and a set of files in BED format that specify, for each sample, where on the chromosome SNPs could have been detected if there were any of them. Further information on the origin of the genomic dataset can be found in the instructions to tutorial [Species-Tree Inference with SNP Data](../species_tree_inference_with_snp_data/README.md). Note, however, that after phasing the VCF file, the number of samples will be reduced to one per species to limit the run time of the analyses. As in tutorial [Divergence-Time Estimation with SNP Data](../divergence_time_estimation_with_snp_data/README.md), the sample selected per species is the one with the least amount of missing data. These samples are listed in the table shown below:

<center>

| Sample ID | Species ID | Species name                  | Tribe         |
|-----------|------------|-------------------------------|---------------|
| IZC5      | astbur     | *Astatotilapia burtoni*       | Haplochromini |
| AUE7      | altfas     | *Altolamprologus fasciatus*   | Lamprologini  |
| JBD6      | telvit     | *Telmatochromis vittatus*     | Lamprologini  |
| JUH9      | neobri     | *Neolamprologus brichardi*    | Lamprologini  |
| LJC9      | neocan     | *Neolamprologus cancellatus*  | Lamprologini  |
| KHA7      | neochi     | *Neolamprologus chitamwebwai* | Lamprologini  |
| IVE8      | neocra     | *Neolamprologus crassus*      | Lamprologini  |
| JWH2      | neogra     | *Neolamprologus gracilis*     | Lamprologini  |
| JWG9      | neohel     | *Neolamprologus helianthus*   | Lamprologini  |
| JWH4      | neomar     | *Neolamprologus marunguensis* | Lamprologini  |
| JWH6      | neooli     | *Neolamprologus olivaceous*   | Lamprologini  |
| ISB3      | neopul     | *Neolamprologus pulcher*      | Lamprologini  |
| ISA8      | neosav     | *Neolamprologus savoryi*      | Lamprologini  |
| KFD2      | neowal     | *Neolamprologus walteri*      | Lamprologini  |

</center>

Moreover, when converting the dataset from VCF into a sequence alignment in Nexus format, only one of the phased haplotypes for each sample will be randomly selected, so that each species is then represented only by a single phased chromosome-length sequence.


<a name="requirements"></a>
## Requirements

* **bcftools:** [bcftools](http://www.htslib.org/doc/bcftools.html) ([Li 2011](https://academic.oup.com/bioinformatics/article/27/21/2987/217423)) is a fast and versatile tool for the manipulation and filtering of variant data in VCF format. Downloads and instructions for installation on Mac OS X and Linux are available at the [HTSlib download webpage](http://www.htslib.org/download/). Installation on Windows is apparently not possible. If you should fail to install bcftools, you could skip the optional [SNP filtering](#filtering) steps in the first part of the tutorial and still run the SVDQuartets analysis.

* **AliView:** To visualize sequence alignments, the software [AliView](http://www.ormbunkar.se/aliview/) ([Larsson 2014](https://academic.oup.com/bioinformatics/article/30/22/3276/2391211)) is recommended. The installation of AliView is described at [http://www.ormbunkar.se/aliview/](http://www.ormbunkar.se/aliview/) and should be possible on all operating systems.

* **PAUP\* (command-line version):** Unlike in tutorials [Substitution Model Selection](../substitution_model_selection/README.md) and [Species-Tree Inference with SNP Data](../species_tree_inference_with_snp_data/README.md), the command-line version of PAUP* will be required for this tutorial. Precompiled binaries of these versions are available for Mac OS X, Linux, and Windwows from the [PAUP\* website]([http://phylosolutions.com/paup-test/](http://phylosolutions.com/paup-test/)). Download the correct version for your system and place it somewhere on your computer where your system can find it (i.e. in a directory that is included in your [PATH](https://en.wikipedia.org/wiki/PATH_(variable))).

* **IQ-TREE:** If you followed tutorials [Maximum-Likelihood Species Tree Inference](../ml_species_tree_inference/README.md), you should already have IQ-TREE installed. If not, you can find the source code for Mac OS X and Linux, as well as precompiled executables for Windows, on [http://www.iqtree.org/#download](http://www.iqtree.org/#download). To install IQ-TREE on any of these systems, download the version for your operating system, and decompress this file on your machine if necessary. In the decompressed directory, you'll find a subdirectory named `bin` and inside of this subdirectory should be a file named `iqtree` or `iqtree.exe`. To easily access this executable from the command line, also place it in a directory that is included in your [PATH](https://en.wikipedia.org/wiki/PATH_(variable))).

* **FigTree:** The program [FigTree](http://tree.bio.ed.ac.uk/software/figtree/) by Andrew Rambaut is a very intuitive and useful tool for the visualization and (to a limited extent) manipulation of phylogenies encoded in [Newick](http://evolution.genetics.washington.edu/phylip/newicktree.html) format. Executables for Mac OS X, Linux, and Windows are provided on [https://github.com/rambaut/figtree/releases](https://github.com/rambaut/figtree/releases).

* **msprime:** The Python library [msprime](https://msprime.readthedocs.io/en/stable/index.html) [(Kelleher et al. 2016)](http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004842) will be required for simulations of recombination. The library can be installed with pip for Python 3, using the following command:

		python3 -m pip install --user msprime
		
	The installation can be tested with these commands:
	
		python3 -c 'import msprime'


<a name="phasing"></a>
## Genotype phasing

When sequences used for phylogenetic inference of diploid organisms include heterozygous sites, inference methods like IQ-TREE usually interpret those sites as being ambiguous for two nucleotides, which means that available information (namely that both nucleotides are in fact present) is not used in the analysis. Ignoring this information could lead to shorter inferred branches for highly heterozygous samples and thus potentially to unreliable phylogenetic estimates. A better alternative is thus to "phase" heterozygous sequences before the phylogenetic analysis, and thus, to replace the single sequence per sample that may contain heterozygous sites with two sequences representing the two haplotypes of the sample. In the absence of long sequencing reads such as those generated on the PacBio platform, any attempt at phasing will most likely not succeed in correctly determining both haplotypes across the entire chromosome. Nevertheless, one could expect that at least within the short regions of the genome that are used for individual phylogenetic analyses, the phasing may be correct. And even if only one of the two sequences per sample are ultimately used for the phylogenetic inference (as will be the case here), phasing will increase the amount of information available for the analysis. Because phasing is more reliable with more samples, we are going to perform phasing before, not after, reducing the dataset to one sample per species.

The two programs [BEAGLE](https://faculty.washington.edu/browning/beagle/beagle.html) ([Browning and Browning 2007](https://www.cell.com/ajhg/fulltext/S0002-9297(07)63882-8)) and [SHAPEIT](https://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html) ([Delaneau et al. 2012](https://www.nature.com/articles/nmeth.1785)) both allow rapid phasing. From my experience, the results of both tools are very comparable. BEAGLE, however, has the advantage that it requires no conversion from VCF format into other formats; therefore, we are here going to use BEAGLE.

* Download the Java jar file of the latest version of BEAGLE from the [BEAGLE webpage](https://faculty.washington.edu/browning/beagle/beagle.html), either using a browser or the following command:

		wget https://faculty.washington.edu/browning/beagle/beagle.28Sep18.793.jar

* Have a look at the available options for BEAGLE, which you should see when you start the program without any input, as with the following command:

		java -jar beagle.28Sep18.793.jar

* Almost all of the default settings are fine for our analysis. We could, however, set the population size estimate used for phasing to a value comparable to the estimate obtained in tutorial [Divergence-Time Estimation with SNP Data](../divergence_time_estimation_with_snp_data/README.md). As this estimate was on the order of 100,000, we'll specify `ne=100000`. According to the [BEAGLE manual](https://faculty.washington.edu/browning/beagle/beagle_5.0_07Sep18.pdf), specifying a correct population size is mainly important when phasing very inbred populations, so this setting is probably not very important in our case. More importantly, make sure to specify that BEAGLE should run on a single CPU with `nthreads=1`. Without this option, BEAGLE will use all CPUs available, which reduces the run time but leads to higher memory requirements that may exceed the available memory on your machine. To run imputation with BEAGLE using a single CPU and up to 4 Gb of memory, run the following command:

		java -jar -Xmx4G beagle.28Sep18.793.jar nthreads=1 ne=100000 gt="NC_031969.f5.sub1.vcf.gz" out="NC_031969.f5.sub1.phased"

	This analysis should take around 7 minutes.

* Have a look at the output file `NC_031969.f5.sub1.phased` written by BEAGLE, for example with `zless -S` using the following command:

		zless -S NC_031969.f5.sub1.phased.vcf.gz

	You should note that the genotypes are now separated with the pipe symbol "|" instead of the forward slash "/", and that a distinction is now being made between heterozygous genotypes such as "0|1" and "1|0". With unphased data, the lower number was always listed first as in "0/1" because their order did not have a meaning, but after phasing, all alleles before the pipe symbol are considered to form one haplotype while those after the pipe symbol form the other. **Question 1:** Do you also notice something that is unexpected? [(see answer)](#q1)

* Given that we did not run BEAGLE with a reference set of haplotypes, we should probably consider the imputed alleles as being potentially incorrect and misleading for phylogenetic analyses. Thus, it might be safer to undo the imputation before using the dataset for phylogenetic analyses. We can do so by comparing the unphased VCF file [`NC_031969.f5.sub1.vcf.gz`](data/NC_031969.f5.sub1.vcf.gz) with the phased VCF file [`NC_031969.f5.sub1.phased.vcf.gz`](res/NC_031969.f5.sub1.phased.vcf.gz) and by setting all genotype in the phased VCF file to missing (coded by ".|.") if they were also missing in the unphased VCF file. This can be done with the Ruby script [`mask_imputed_gts.rb`](src/mask_imputed_gts.rb). However, the script expects as input both the unphased and phased VCF files without their headers; thus, we'll first generate versions of the two files with their headers removed. We can do so with the following commands:

		gunzip -c NC_031969.f5.sub1.vcf.gz | grep -v "#" > original.vcf
		gunzip -c NC_031969.f5.sub1.phased.vcf.gz | grep -v "#" > phased.vcf

* Then, run the script [`mask_imputed_gts.rb`](src/mask_imputed_gts.rb) with the names of the two files generated in the last step as input, followed by the name of a new file, `masked.vcf`, to which the output of the script will be written:

		ruby mask_imputed_gts.rb original.vcf phased.vcf masked.vcf

* Have a look at file `masked.vcf`, for example with using `less -S` as in the following command:

		less -S masked.vcf

	You should see that this file does contain the phased genotypes marked by the pipe ("|") symbol separating the two alleles, but that it also includes missing data just like the unphased file `NC_031969.f5.sub1.vcf.gz` did.
	
* Finally, because the file `masked.vcf` does not contain a header, we will generate a new file containing only the header of the unphased file `NC_031969.f5.sub1.vcf.gz`, and we will combine this file containing only the header with the header-less file `masked.vcf` into a new file. We will also compress the new file at the same time and name it `NC_031969.f5.sub1.phased.masked.vcf.gz`. To do so, use the following two commands:

		gunzip -c NC_031969.f5.sub1.vcf.gz | grep "#" > header.vcf
		cat header.vcf masked.vcf | gzip > NC_031969.f5.sub1.phased.masked.vcf.gz
		
* Before continuing with the next section of the tutorial, you might want to remove some of the larger files generated in the last couple of steps that we will not need anymore. To do so, use the following command:
		
		rm original.vcf header.vcf phased.vcf masked.vcf


<a name="preparing"></a>
## Preparing a chromosome-length alignment

In this part of the tutorial, we are going to prepare a single chromosome-length alignment, including one phased sequence for each of the 14 cichlid species included in the dataset. We are going to need three different sources of information:

1.	The VCF file [`NC_031969.f5.sub1.phased.masked.vcf.gz`](res/NC_031969.f5.sub1.phased.masked.vcf.gz) with phased SNP variation generated in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md).

2. As the VCF file `NC_031969.f5.sub1.phased.masked.vcf.gz` does not contain information about invariant sites but these are required for phylogenetic inference with BEAST2, we assume that the sites between those included in the VCF file are in fact unchanged between the species in the dataset and the tilapia reference sequence. Thus, we'll use the reference sequence for chromosome 5 of tilapia to fill the gaps between SNPs included in the VCF. 		
3. The assumption that sites between SNPs are invariant is only justified for sites in which SNPs could have been called at all if there had been any. This is not the case for all sites between the SNPs, due to low sequencing coverage in some regions or low mapping quality in repetitive regions. It would also have been impossible to call SNPs very close to indel variation, because these were filtered when the original VCF file `NC_031969.f5.sub1.vcf.gz` (see tutorial [Species-Tree Inference with SNP Data](../species_tree_inference_with_snp_data/README.md)) was prepared. Thus, we will take into account information about the chromosomal regions in which SNP variation could not have been called in the first place, and we will conservatively set these chromosomal regions to missing, coded by "N", in the generated alignment. The information about callable chromosomal regions is contained in a set of files in [BED format](http://genome.ucsc.edu/FAQ/FAQformat#format1); these files are within a compressed directory named [`masks.tgz`](data/masks.tgz).

* Obtain all required input files and place them in your analysis directory. To download the sequence for chromosome 5 of tilapia from GenBank, you can use the following command:

		wget 'http://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?tool=portal&sendto=on&log$=seqview&db=nuccore&dopt=fasta&val=NC_031969.1&extrafeat=0&maxplex=1' -O NC_031969.fasta
		
	The downloaded sequence will in in Fasta format in a file named `NC_031969.fasta`.

* Unless the directory with the files in BED format has already been uncompressed automatically, do so with the following command:

		tar -xzf masks.tgz
		
* Have a look at the content of one of the files in BED format, for example using the following command:

		less masks/AUE7.NC_031969.f5.merged.bed
		
	You'll see that these files contain three columns, as shown in the text below:
	
		NC_031969       0       45144
		NC_031969       45169   88297
		NC_031969       88299   88363
		NC_031969       88365   88370
		NC_031969       88372   98367
		NC_031969       98368   98403
		NC_031969       98405   98409
		NC_031969       98411   98429
		NC_031969       98431   100023
		...
		
	The second and third of these columns indicate the beginning and the end of chromosomal regions that were masked because SNPs in these regions would not have been detected due to low coverage or other reasons. You'll see that these uncallable regions are quite long compared to the callable regions in between them. In the example shown above, only few callable sites were found within the first 100 kb of the chromosome. Overall, about two thirds of the chromosome are uncallable, which can be explained by a combination of several causes, including mapping to a distant reference, masking of repetitive regions, and rigorous filtering of sites close to insertions and deletions. However, even after conservatively setting all these regions to missing, the remaining sequence information will be more than sufficient for phylogenetic analysis.

* The three different types of information (the SNP data, the reference sequence, and the information on uncallable regions) will be combined to generate chromosome-length sequences in Fasta format by the Ruby script [`fill_seq.rb`](src/fill_seq.rb). To reduce the memory requirement of this script, we are going to run it separately for each of the samples included in the dataset, and as input for the script we are going to use individual VCF files that contain SNP data only for the respective sample. Prepare these individual VCF files from the full VCF file [`NC_031969.f5.sub1.phased.masked.vcf.gz`](data/NC_031969.f5.sub1.phased.masked.vcf.gz), using the following command (if you copied the VCF file from the analysis directory of tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md), it might be uncompressed; if so, just remove the file extension `.gz` in this command):

		for i in IZC5 AUE7 JBD6 JUH9 LJC9 KHA7 IVE8 JWH2 JWG9 JWH4 JWH6 ISB3 ISA8 KFD2
		do
			bcftools view -s ${i} -o ${i}.NC_031969.f5.masked.vcf NC_031969.f5.sub1.phased.masked.vcf.gz
		done
		
	The above command should have written 14 separate uncompressed VCF files. To make sure that these have been generated, you could use `ls *.NC_031969.f5.masked.vcf`.

* We can now run the script [`fill_seq.rb`](src/fill_seq.rb) to combine, for each sample, the SNP data with the reference sequence and the information on callable regions, using the following command:

		for i in *.NC_031969.f5.masked.vcf
		do
			sample_id=`basename ${i%.NC_031969.f5.masked.vcf}`
			echo -n "Translating file ${i}..."
			ruby fill_seq.rb ${i} NC_031969.fasta masks/${sample_id}.NC_031969.f5.merged.bed ${sample_id}.NC_031969.f5.masked.fasta 1
			echo " done."
		done

	 This should take about ten minutes to finish. As you can see from the command above, the script `fill_seq.rb` expects five command-line arguments. These are, in this order,
	
	* the VCF file with SNP information,
	* the reference sequence in Fasta format,
	* the file in BED format containing information about callable regions,
	* the name of an output file, which will be written in Fasta format.
	* a flag specifying whether only the first, the second, or both phased haplotypes should be written to the output. Here, we arbitrarily chose the first haplotype.

	The script expects that all input files are for a single chromosome only, so we would have to run it multiple times if we would use information from several chromosomes.

* Have a look at one of the Fasta files generated by script `fill_seq.rb`, for example using the following command:

		less -S AUE7.NC_031969.f5.masked.fasta
		
	You'll see that it contains a single sequence, which corresponds to the first haplotype of the phased VCF file.

* Next, combine all sequences into a single file in Fasta format named `NC_031969.f5.masked.fasta`. Because all sequences are already aligned in the same way to the tilapia reference sequence, the combined file will already be perfectly aligned and no realignment with a tool like MAFFT (see tutorial [Multiple Sequence Alignment](../multiple_sequence_alignment/README.md)) will be necessary. The combined Fasta file `NC_031969.f5.masked.fasta` will have a file size of about 500 MB. To combine the sequences, execute the following command:

		cat *.NC_031969.f5.masked.fasta > NC_031969.f5.masked.fasta
		
* You could now remove the per-sample Fasta and VCF files to save disk space, using the following command:

		rm *.NC_031969.f5.masked.fasta
		rm *.NC_031969.f5.masked.vcf


<a name="blocks"></a>
## Identifying alignment blocks for phylogenetic analysis

After having generated a chromosome-length alignment, we can now apply a sliding-window approach to identify blocks of the alignment that are suitable for phylogenetic analysis. Ideally, the blocks used for phylogenetic analysis should have as little missing data as possible, be as informative as possible, and show no signs of within-block recombination. In this part of the tutorial, we are going to extract alignment blocks from the chromosome-length alignment and we will further filter these based on informativeness and signals of recombinaiton.

As the length of each block, we here use 5 kb, assuming that this length is a good compromise between increasing probability of undetected recombination with longer blocks and decreasing phylogenetic signal with shorter blocks. For a more thorough analysis, however, it might be worth testing this assumption with blocks of different sizes.

* To extract alignment blocks from the chromosome-length alignment, we can use the Ruby script [`extract_blocks.rb`](src/extract_blocks.rb). This script expects four command-line arguments; these are
	* the name of the chromosome-length alignment in Fasta format,
	* the name of a new directory to which all block-alignment files will be written in Nexus format,
	* the size of the alignment blocks,
	* (optionally) a maximum proportion of missing data allowed in alignment blocks.

	Thus, to name the output directory `blocks`, use a block size 5,000 bp, and allow maximally half of the alignment to consist of missing data, run the script with the following command:
	
		ruby extract_blocks.rb NC_031969.f5.masked.fasta blocks 5000 0.5
		
	**Question 2:** How many alignment blocks were written and how many were removed due to a high proportion of missing data? [(see answer)](#q2)
	
* Have a look at the new directory named `blocks`. Note that the files in this directory are named according to the name of the linkage group and the first and the last position of the alignment block:

		NC_031969.f5.masked_02505001_02509999.nex
		NC_031969.f5.masked_04865001_04869999.nex
		NC_031969.f5.masked_04910001_04914999.nex
		NC_031969.f5.masked_04925001_04929999.nex
		NC_031969.f5.masked_04935001_04939999.nex
		NC_031969.f5.masked_05010001_05014999.nex
		NC_031969.f5.masked_05030001_05034999.nex
		...

* To facilitate the phylogenetic analyses, it will help to simplify the alignment names with the following set of commands.

		for i in blocks/*.nex
		do
			new_name=`echo ${i} | sed 's/\.f5\.masked//g'`
			mv ${i} ${new_name}
		done

* The files in directory `blocks` should now be named like this:

		NC_031969_02505001_02509999.nex
		NC_031969_04865001_04869999.nex
		NC_031969_04910001_04914999.nex
		NC_031969_04925001_04929999.nex
		NC_031969_04935001_04939999.nex
		NC_031969_05010001_05014999.nex
		NC_031969_05030001_05034999.nex
		...

* Pick one of the files in this directory at random, and open it either in a text editor or in AliView just to get a feeling for the size of the alignment block, as well as for its sequence variation and the amount of missing data. You should see something like this:<p align="center"><img src="img/aliview1.png" alt="AliView" width="600"></p> Like the alignment shown above, many alignments still contain quite a proportion of missing data due to the strict filtering based on coverage, mapping quality, and indel proximity.

* To filter the alignment blocks by phylogenetic informativeness, we are going to quantify their numbers of parsimony-informative sites. These are the sites at which at least two sequences share a derived site, so that their grouping is supported by this site. In other words, parsimony-informative sites result only from subsitutions on internal branches of the phylogeny, not from those that occur on terminal branches. The Ruby script [`get_number_of_pi_sites.rb`](src/get_number_of_pi_sites.rb) allows the quick calculation of this number from an alignment in Nexus format. Run this script with the following command to quantify the numbers of parsimony-informative sites in all alignment blocks:

		for i in blocks/*.nex
		do
			ruby get_number_of_pi_sites.rb ${i}
		done

	This should show that most alignments contain between 10 and 30 parsimony-information sites. Particularly those with 10 or less such sites will not be informative enough to fully resolve the phylogeny of the 14 species in the dataset, because even if every internal branch would be supported by only a single substitution, this would require 11 parsimony-informative sites.

* Before applying a threshold on the number of parsimony-informative sites, we are going to quantify the number of so-called hemiplasies in each alignment block as a second criterion for filtering. Simply put, a hemiplasy is a site that supports a grouping that is in conflict with a grouping supported by another site of the same alignment. Possible explanations for hemiplasy include sequencing errors but within-alignment recombination in combination with incomplete lineage sorting can also produce hemiplasies. And because within-alignment recombination can lead to unreliable phylogenetic inference, this means that alignments with none of few hemiplasies are more suitable for phylogenetic inference than other alignments with many hemiplasies ([Maynard Smith and Smith, 1998](https://academic.oup.com/mbe/article/15/5/590/987861)).

	Fortunately, the number of hemiplasies can easily be approximated as the difference between the number of variable sites and the so-called parsimony score of an alignment, which is the lowest number of substitutions on a phylogeny that is required to produce the alignment (the result is only an approximation because some hemiplasies may increase the parsimony-score by more than 1 if three or more substitutions are required to explain them). To calculate the number of variable sites, the script [`get_number_of_variable_sites.rb`](src/get_number_of_variable_sites.rb) can be used. Before moving on to calculate parsimony scores, first apply script [`get_number_of_variable_sites.rb`](src/get_number_of_variable_sites.rb) to get a feeling of the number of variable sites in the alignments:
	
		for i in blocks/*.nex
		do
			ruby get_number_of_variable_sites.rb ${i}
		done

	You should see that most alignments have around 40-70 variable sites, but some particularly variable alignments have over 100.

* The calculation of parsimony scores requires that the software PAUP* is installed on the command line, which can be checked with `paup -V`. If PAUP* seems to be working, the BASH script [`get_parsimony_score.sh`](src/get_parsimony_score.sh) can be used to obtain the parsimony score of a Nexus-format alignment. This script performs several steps: It writes a command file for PAUP* which specifies the task that PAUP* should perform as well as the input file, then it runs PAUP* with this command file, it reads the output of PAUP* to extract the parsimony score, and finally, it removes the temporary files that were written by PAUP* to clean up the directory. To see whether this process works well, run script [`get_parsimony_score.sh`](src/get_parsimony_score.sh) with a randomly selected alignment file, for example, using:

		bash get_parsimony_score.sh blocks/NC_031969_08400001_08404999.nex
		
	With this alignment, the parsimony score is 115.
	
* Now, let's combine the different scripts to quantify parsimony-score and the number of hemiplasies for all alignments, and record this information in a table. The following block of code will allow this, writing the result to a new file named `block_stats.txt`:

		echo -e "id\tn_pi_sites\tn_hemiplasies" > block_stats.txt
		for i in blocks/*.nex
		do
			id=`basename ${i%.nex}`
			n_pi_sites=`ruby get_number_of_pi_sites.rb ${i}`
			n_variable_sites=`ruby get_number_of_variable_sites.rb ${i}`
			parsimony_score=`bash get_parsimony_score.sh ${i}`
			n_hemiplasies=$((${parsimony_score}-${n_variable_sites}))
			echo -e "${id}\t${n_pi_sites}\t${n_hemiplasies}"
		done >> block_stats.txt

* Have a look at the content of file [`block_stats.txt`](res/block_stats.txt). The first part of the content should be the following, where the number of parsimony-informative sites is written in the second column and the third column contains the (approximated) number of hemiplasies:

		id	n_pi_sites	n_hemiplasies
		NC_031969_02505001_02509999	13	2
		NC_031969_04865001_04869999	6	3
		NC_031969_04910001_04914999	8	6
		NC_031969_04925001_04929999	13	11
		NC_031969_04935001_04939999	5	2
		NC_031969_05010001_05014999	6	1
		NC_031969_05030001_05034999	8	2
		NC_031969_05040001_05044999	9	3
		NC_031969_05065001_05069999	15	11
		NC_031969_05185001_05189999	12	9
		NC_031969_05220001_05224999	19	16
		NC_031969_05230001_05234999	14	7
		NC_031969_05255001_05259999	5	1
		NC_031969_05915001_05919999	44	39
		NC_031969_05920001_05924999	36	37
		...

	It appears that the two values are closely correlated: the more parsimony-informative sites an alignment has the more hemiplasies is contains. This is in part expected because without parsimony-informative sites there could be no hemiplasies. It means, however, that a compromise will need to be made between too little information and too many hemiplasies, indicating within-alignment recombination.
	
* To allow us to decide on appropriate thresholds for the numbers of parsimony-informative sites and hemiplasies, let's plot the two values. In the R environment, you could use the following commands to do so (just type `R` to enter the R environment from the command line):

		table <- read.table("block_stats.txt", header=T)
		pdf("block_stats.pdf", height=7, width=7)
		plot(table$n_pi_sites, table$n_hemiplasies, xlim=c(0,70), ylim=c(0,70), xlab="Parsimony-informative sites", ylab="Hemiplasies")
		abline(a=0, b=1)
		dev.off()

	(to quit the R environment, type `quit(save="no")`). This should produce the plot shown below, written to file [`block_stats.pdf`](res/block_stats.pdf), where the black line indicates the diagonal:<p align="center"><img src="img/block_stats.png" alt="Block stats" width="600"></p> The fact that some points lie above the diagonal means the these alignments have more hemiplasies than parsimony-informative, which can only be explained by site patterns that require more than three changes on even the most parsimonious phylogeny. These results suggest that none of the alignments are free of recombination; therefore, the phylogenies that will be inferred from these alignments may not be completely reliable. Selecting shorter alignment blocks could help to reduce within-alignment recombination; however, this would also further reduce the informativeness of the alignments, which is already low in the current alignments.
	
	Given the above plot, a reasonable choice for filtering the most suitable alignments may be to exclude those with less than 15 parsimony-informative sites, those with more than 30 hemiplasies, and those in which the difference between the numbers of parsimony-informative sites and hemiplasies is less than 5. The added lines in the plot below indicate the selected region of the block (the region to the bottom-right of the three lines):p align="center"><img src="img/block_stats_region.png" alt="Block stats" width="600"></p>
	
* Remove all block alignments that are considered unsuitable according to these thresholds for the numbers of parsimony-informative sites and hemiplasies as well as the difference between them. Use the following set of commands to do so:
	
		cat block_stats.txt | tail -n +2 > tmp.txt
		while read line
		do
		    id=`echo ${line} | cut -d " " -f 1`
		    n_pi_sites=`echo ${line} | cut -d " " -f 2`
		    n_hemiplasies=`echo ${line} | cut -d " " -f 3`
			if (( ${n_pi_sites} < 15 )) || (( ${n_hemiplasies} > 30 )) || (( ${n_pi_sites} < ${n_hemiplasies} + 5 ))
			then
				echo "Removing file blocks/${id}.nex"
				rm blocks/${id}.nex
			fi
		done < tmp.txt
		rm tmp.txt

	**Question 3:** How many block alignments remain in the `blocks` directory after applying these thresholds? [(see answer)](#q3)


<a name="iqtree"></a>
##Inferring block phylogenies with IQ-TREE

In this part of the tutorial, we are going to infer phylogenies for each remaining alignment block; the set of inferred phylogenies will subsequently be used to determine asymmetries in the topologies of species trios which can serve as an indicator for introgression. Note that it may in fact be important for this subsequent test that the set of phylogenies is generated based on maximum likelihood, without assuming a clock model as in BEAST analyses. While this should probably be tested in more detail, I found in preliminary analyses that clock-rate variation among species may influence the frequencies of species-trio topologies in time-calibrated analyses, but that it has no or only weak effect on maximum-likelihood inference without a clock model. As a result, I also do not recommend any longer to use the related approach of [Meyer et al. (2017)](https://academic.oup.com/sysbio/article/66/4/531/2670093).

* As in tutorials [Maximum-Likelihood Phylogenetic Inference](../ml_phylogeny_inference/README.md) and [Maximum-Likelihood Species-Tree Inference](../ml_species_tree_inference/README.md), we are going to use IQ-TREE for maximum-likelihood phylogenetic inference, and we do not specify a substitution model, allowing IQ-TREE to automatically select the best model itself. No bootstrap replicates are required this time, but we will need to specify the sample ID for the included individual of *Astatotilapia burtoni*, IZC5, as the outgroup, so the resulting trees are rooted. To run IQ-TREE with for all alignments use the following command:

		for i in blocks/*.nex
		do
			iqtree -s ${i} -o IZC5
		done

	IQ-TREE should require around 10 minutes to finish the phylogenetic analysis for all block alignments.
	
* Combine all inferred phylogenies into a single file, using the following command:

		cat blocks/*.treefile > block_phylogenies.trees
		
* You could then remove all output files produced by IQ-TREE to clean up the directory:

		rm blocks/*.nex.*

* Before analyzing asymmetry in the topologies of species trios in the next section, we'll first replace the sample IDs in the tree file [`block_phylogenies.trees`](res/block_phylogenies.trees) with the corresponding species names; this will facilitate the interpretation of the results. To prepare this translation, write the following table of sample IDs and species names to a new file named `samples.txt` (note that the content of this file is different from other files with the same name used in other tutorials):

		IZC5	astbur
		AUE7	altfas
		JBD6	telvit
		JUH9	neobri
		LJC9	neocan
		KHA7	neochi
		IVE8	neocra
		JWH2	neogra
		JWG9	neohel
		JWH4	neomar
		JWH6	neooli
		ISB3	neopul
		ISA8	neosav
		KFD2	neowal
		
	(make sure that the last line end with a line break).

* To then replace all sample IDs in the tree file [`block_phylogenies.trees`](res/block_phylogenies.trees) and write a new file named `block_phylogenies.renamed.trees`, you can use the following set of commands:

		cp block_phylogenies.trees tmp.trees
		while read line
		do
			sample_id=`echo ${line} | cut -d " " -f 1`
			species_name=`echo ${line} | cut -d " " -f 2`
			cat tmp.trees | sed "s/${sample_id}/${species_name}/g" > tmp2.trees
			mv -f tmp2.trees tmp.trees
		done < samples.txt
		mv tmp.trees block_phylogenies.renamed.trees

* You may want to browse through some of the block phylogenies to get a feeling of how reliable they could be. To do so, open file [`block_phylogenies.renamed.trees`](res/block_phylogenies.renamed.trees) in FigTree. The first phylogeny should look as shown in the screenshot below:<p align="center"><img src="img/figtree1.png" alt="FigTree" width="600"></p> This block phylogeny is rather different from the species tree inferred with SNAPP in tutorial [Species-Tree Inference with SNP Data](../species_tree_inference_with_snp_data/README.md). For comparison, this species tree is shown in the next screenshot:<p align="center"><img src="img/figtree2.png" alt="FigTree" width="600"></p> For example, the species tree strongly supports monophyly of *Neolamprologus chitamwebwai* ("neochi") and *N. walteri* ("neowal"), but the latter species is closer to *Telmatochromis vittatus* ("telvit") in the block phylogeny. Such differences can of course be due to incomplete lineage sorting, but they could also arise from low information content of the alignment. Brownse through some of the other block phylogenies contained in file [`block_phylogenies.renamed.trees`](res/block_phylogenies.renamed.trees) by clicking on on arrows at the top right of the FigTree window.

* Finally, we could quantify the differences between all block phylogenies and the species tree generated with SNAPP. The [Robinson-Foulds distance](https://en.wikipedia.org/wiki/Robinsonâ€“Foulds_metric), measuring the number of nodes that one would need to change to convert one tree into the other, would be suitable to quantify this differene and can quickly be calculated with IQ-TREE (as in tutorial [Maximum-Likelihood Phylogenetic Inference](ml_phylogeny_inference)). To do so, use file [`snapp.nwk`](data/snapp.nwk), which is a version of the species tree in Newick format. Then, calculate the Robinson-Foulds distance between all block phylogenies and the species tree with the following command:

		iqtree -t block_phylogenies.renamed.trees -rf snapp.nwk

	The screen output should indicate that the results were written to a file named `block_phylogenies.renamed.trees.rfdist`.
	
* Have a look at file [`block_phylogenies.renamed.trees.rfdist`](res/block_phylogenies.renamed.trees.rfdist), for example with the `less` command. This should show that most block phylogenies have a Robinson-Foulds distance from the species tree around 20. This is quite high and indicates either very pervasive incomplete lineage sorting, very low information content in the alignments, or both. But as we will see, the collection of block phylogenies will nevertheless be very useful to identify introgression.


<a name="asymmetry"></a>
##Analyzing asymmetry of trio topologies

Analogous to the logic behind the ABBA-BABA test in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md), asymmetry in the topologies of species trios can be used to identify past introgression. In the absence of introgression, we would expect that local phylogenies of three species P1, P2, and P3 most frequently support the topology of the true species tree (e.g. a clade formed by P1 and P2 if these are in fact sister species), and that the two alternative topologies (e.g. a clade formed by P1 and P3 or a clade formed by P2 and P3) should occur equally frequently. A significant difference in the frequencies of the two alternative topologies is therefore not compatible with a null hypothesis of no introgression, meaning that such a significant difference would support the occurrence of past introgression. An important difference to the ABBA-BABA test may be that the analysis of tree asymmetry could be more robust to rate variation among species; however, this hypothesis remains to be tested with simulations.

To analyze the frequencies of alternative trio topologies in the set of block phylogenies, we can use the Ruby script [`analyze_tree_asymmetry.rb`](src/analyze_tree_asymmetry.rb). This script should work well with any file that contains a set of trees in Newick format. It determines the set of species in these trees, and then tests for each possible species trio how often two of the three species form a pair relative to the third species. These frequencies are then used to place the three species in positions P1, P2, and P3 so that

*N*<sub>(P1,P2)</sub> > *N*<sub>(P2,P3)</sub> > *N*<sub>(P1,P3)</sub>,

where *N*<sub>(P1,P2)</sub> is the frequency at which P1 and P2 form a pair, *N*<sub>(P2,P3)</sub> is the frequency of pairs formed by P2 and P3, and *N*<sub>(P1,P3)</sub> is the frequency of pairs formed by P1 and P3. An equivalent to the *D*-statistic is then calculated as

*D* = (*N*<sub>(P2,P3)</sub> - *N*<sub>(P1,P3)</sub>) / (*N*<sub>(P2,P3)</sub> + *N*<sub>(P1,P3)</sub>)

and a *p*-value for the null hypothesis of no imbalance between *N*<sub>(P1,P3)</sub> and *N*<sub>(P2,P3)</sub> is calculated based on a [binomial test](https://en.wikipedia.org/wiki/Binomial_coefficient).

* To quantify tree asymmetry, run the script [`analyze_tree_asymmetry.rb`](src/analyze_tree_asymmetry.rb) with the tree file [`block_phylogenies.renamed.trees`](res/block_phylogenies.renamed.trees), and specify that the output should be written to a new file named `block_topology_frequencies.txt`, using the following command:

		ruby analyze_tree_asymmetry.rb block_phylogenies.renamed.trees block_topology_frequencies.txt

* Have a look at the file [`block_topology_frequencies.txt`](res/block_topology_frequencies.txt) produced by script `analyze_tree_asymmetry.rb`, for example using the `less` command:

		less block_topology_frequencies.txt

	The content of this file should show the following:
	
		p1        p2        p3         n(p1,p2)  n(p2,p3)  n(p1,p3)    d         p
		neobri    altfas    astbur           66         0         0    0.000    1.00000000
		neocan    altfas    astbur          183         0         0    0.000    1.00000000
		neochi    altfas    astbur           66         0         0    0.000    1.00000000
		neocra    altfas    astbur           61         0         0    0.000    1.00000000
		neogra    altfas    astbur           62         0         0    0.000    1.00000000
		neohel    altfas    astbur           61         0         0    0.000    1.00000000
		neomar    altfas    astbur           67         0         0    0.000    1.00000000
		neooli    altfas    astbur           63         0         0    0.000    1.00000000
		neopul    altfas    astbur           67         0         0    0.000    1.00000000
		neosav    altfas    astbur           60         0         0    0.000    1.00000000
		neowal    altfas    astbur           67         0         0    0.000    1.00000000
		telvit    altfas    astbur           76         0         0    0.000    1.00000000
		altfas    neocan    neobri          171        60         7    0.791    0.00000000
		neobri    neochi    altfas          162        43        33    0.132    0.30187249
		neocra    neobri    altfas          204        19        15    0.118    0.60759136
		...

	The format of this file is similar to that written by the program Dsuite in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md). Each row includes results for one species trio, with the frequencies of the three alternative topologies in columns 4 to 6, followed by the equivalent to the *D*-statistic in the seventh column and the *p*-value in the last. The trios in the first couple of rows include *Astatotilapia burtoni* ("astbur"), and because that species is the outgroup, it is not surprising that the frequencies *N*<sub>(P1,P3)</sub> and *N*<sub>(P2,P3)</sub> are 0. The reason why only a proportion of the 238 phylogenies support *N*<sub>(P1,P2)</sub> is that, as in the screenshot of a block phylogeny shown above, IQ-TREE places the outgroup with another species in a polytomy at the root, and the script [`analyze_tree_asymmetry.rb`](src/analyze_tree_asymmetry.rb) ignores trios connected by polytomies. But since the frequencies of topologies in species trios that include the outgroup are by definition never asymmetric, those comparisons could be ignored anyway. More conclusive results are shown in the subsequent rows of the table, for example for the trio of "altfas", "neocan", and "neobri", where 171 block phylogenies pair "altfas" and "neocan" and 60 phylogenies pair "neocan" and "neobri", but only 7 phylogenies pair "altfas" and "neobri". As indicated by *D*-statistic of 0.791 and the *p*-value of 0, this asymmetry can not be explained by incomplete lineage sorting alone. **Question 4:** Which species trio has the highest *D* value in this table? [(see answer)](#q4)

* A good way of plotting the asymmetry among alternative trio topologies, and the significance of this asymmetry, is in the form of a heatmap, just like the results of the Dsuite analyses were plotted in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md). This heatmap plot can be generated with the Ruby script [`plot_tree_asymmetry.rb`](src/plot_tree_asymmetry.rb). This script requires the following three command-line arguments:

	* the name of the file produced by script `analyze_tree_asymmetry.rb`,
	* the name of a file that lists the order in which the species should be listed along the heatmap axes,
	* the maximum *D*-statistic to be shown in the plot,
	* the name of the output file, which will be in scalable vector graphic (SVG) format.

	Thus, the only input that is missing is the file specifying the order in which species should be plotted. To generate this file, simply copy the list below and save it in a file named `species_order.txt`:

		astbur
		altfas
		neocan
		neochi
		neowal
		telvit
		neosav
		neocra
		neomar
		neogra
		neohel
		neobri
		neooli
		neopul

* Use script [`plot_tree_asymmetry.rb`](src/plot_tree_asymmetry.rb) with files [`block_topology_frequencies.txt`](res/block_topology_frequencies.txt) and [`species_order.txt`](res/species_order.txt) as input, specify a maximum *D*-statistic of 0.7, and name the output file `block_topology_frequencies.svg`:

		ruby plot_tree_asymmetry.rb block_topology_frequencies.txt species_order.txt 0.7 block_topology_frequencies.svg

	Open the output file [`block_topology_frequencies.svg`](res/block_topology_frequencies.svg) file with a program capable of reading files in SVG format, for example with a browser such as Firefox or with Adobe Illustrator. The heatmap plot should look as shown below:<p align="center"><img src="img/asymmetry.png" alt="Heatmap D" width="600"></p>

	Clearly the by far strongest signal is shown for comparisons of *Neolamprologus cancellatus* ("neocan") and either other species of the genus or *Telmatochromis vittatus* ("telvit"). While this heatmap does not allow us to tell whether "neocan" was in the P2 or P3 position in those trios that produced these large *D*-statistics, a comparison with file [`block_topology_frequencies.txt`](res/block_topology_frequencies.txt) reveals that the largest *D*-statistics result from trios that have "neocan" in the P2 position. This can be confirmed e.g. with the following command:
	
		cat block_topology_frequencies.txt | tail -n +2 | sort -n -k 7 -r | less

	The patterns of topology asymmetry therefore strongly support introgression between *Neolamprologus cancellatus* ("neocan") and either another *Neolamprologus* or *Telmatochromis vittatus* ("telvit"). Given that the highest *D*-statistic is found for the trio with *Telmatochromis vittatus*, these results therefore corroborate those obtained in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md), according to which *Neolamprologus cancellatus* is formed by hybridization between *Altolamprologus fasciatus* and *Telmatochromis vittatus*.



##XXX


		ruby extract_blocks.rb NC_031969.f5.masked.fasta blocks 1000 0.75







As we have seen in this part of the tutorial, both divergence times in local phylogenies as well as topology frequencies support several instances of introgression among the cichlid species included in our dataset. In the extreme case of *Neolamprologus cancellatus*, the hypothesis of introgression from *Telmatochromis vittatus* was strongly supported by the results obtained in tutorial [Analysis of Introgression with SNP Data](../analysis_of_introgression_with_snp_data/README.md), which even suggested that the *Neolamprologus cancellatus* samples are first-generation hybrids between *Telmatochromis vittatus* and *Altolamprologus fasciatus*. However, some of the other introgression events suggested here by patterns of mean divergence times and and topology frequencies have not yet been explicitly tested (with e.g. the ABBA-BABA test) and might need to be further investigated. Considering that we only used data from a single chromosome and just a single sample per species, more definite conclusions could certainly be gained from more extensive analyses!


<a name="cgenie"></a>
## Simulating recombination with c-genie

One assumption underlying all phylogenetic analyses in this tutorial is that the alignment blocks used for tree inference are free of recombination. If this assumption should be violated, the consequences for the accuracy of the phylogenetic analyses as as well as all analyses of introgression based on these phylogenies would be difficult to predict. Given that we performed two different tests for recombination, with Saguaro and Phi Test, and that the alignment blocks used for phylogenetic analyses passed both tests, one could probably argue that we minimized the possible effect of recombination sufficiently so that our conclusions based on the inferred phylogenies may well be reliable. However, how certain can we be that recombination is really absent from the alignments? And how would our inference be influenced if it were not? 

These questions are so far rather poorly answered, even though they are actively debated in the recent literature (e.g. [Springer and Gatesy 2016](https://www.sciencedirect.com/science/article/pii/S1055790315002225); [Edwards et al. 2016](https://www.sciencedirect.com/science/article/pii/S1055790315003309?via%3Dihub)). One way to approach this question is with simulations: We could simulate how probable it would be to actually have not even a single recombination breakpoint in an alignment of a certain length, and simulated sequences could also be used to test the reliability of phylogenetic inference under these conditions. In one such study, [Lanier and Knowles (2012)](https://academic.oup.com/sysbio/article/61/4/691/1637909) concluded that within-alignment recombination had no noticeable effect on species-tree reconstruction; however, the simulations used in this study were for a rather small set of species, and it is not clear if the results would hold for larger phylogenies. Furthermore, the possible effects of within-alignment recombination on phylogenomic tests for introgression have so far not been tested.

To address at least the question of how probable the absence of recombination is in alignment blocks of 50 kb, we can use the Python program [c-genie](https://github.com/mmatschiner/c-genie) (Malinsky and Matschiner; unpublished). This program simulates phylogenetic histories with recombination and calculates the average length of "c-genes" ("coalescent genes"; [Doyle 1995](https://www.jstor.org/stable/2419811)), genomic regions uninterrupted by recombination. In addition, c-genie also calculates the lengths of "single-topology tracts", fragments sharing the same tree topology even though recombination within these fragments might have led to variable branch lengths in different parts of the fragment. The length of these single-topology tracts might be more relevant for phylogenetic analysis, because one could argue that only those recombination breakpoints that change the tree topology within an aligment have negative consequence for phylogenetic inference while those breakpoints that only change the branch lengths are safe to ignore.

As the probability of recombination depends on many factors, including the recombination rate, the generation time, the length of branches in the species tree, and the population size, c-genie requires estimates for these parameters as input. Conveniently, we can use the species tree as well as the population size estimate inferred by SNAPP in tutorial [Divergence-Time Estimation with SNP Data](../divergence_time_estimation_with_snp_data/README.md) for the simulations with c-genie. In addition, we'll assume (as in other tutorials) again a generation time of 3 years for cichlid fishes as well as a recombination rate of 2&times;10<sup>-8</sup> per generation.

* Start by download the c-genie program from its [github repository](https://github.com/mmatschiner/c-genie), using the following command:

		wget https://raw.githubusercontent.com/mmatschiner/c-genie/master/c-genie

* Make c-genie executable with this command:

		chmod +x c-genie

* Then, have a look at the help text of c-genie with this command:

		./c-genie -h
		
	You'll see that besides calculating the lengths of c-genes and single-topology tracts, c-genie also allows the simulation of alignments with recombination, which can then be used to test the accuracy of phylogenetic methods in the presence of within-alignment recombination. Here, however, we will use c-genie only to find out how plausible the assumed absence of recombination in our 50 kb-alignment blocks really is.
	
* You may also have noticed from c-genie's help text that a generation time of 3 years and a recombination rate of 2&times;10<sup>-8</sup> are already the default values for these two parameters, thus we only need to specify the species tree and the population size estimate from the SNAPP analysis in tutorial [Divergence-Time Estimation with SNP Data](../divergence_time_estimation_with_snp_data/README.md). Thus, copy the species tree named [`snapp.tre`](data/snapp.tre) from the analysis directory of the other tutorial if you followed it, or download the tree file by clicking on the link.

* Now, run c-genie with file [`snapp.tre`](data/snapp.tre) as the species tree, "lamprologini" as the prefix for the file, and an assumed population size of 100,000, according to the estimate from the SNAPP analysis:

		./c-genie snapp.tre lamprologini -n 100000

	This anaysis should finish within a few minutes.
	
* As you will see from the screen output of c-genie, an output file in HTML format has been written to file [`lamprologini.html`](res/lamprologini.html). Open this HTML file in a web browser such as Firefox and scroll through the plots included in this file.

	**Question 11:** What are the mean lengths of c-genes and single-topology tracts? What is the probability that an alignment of 50 kb includes just one c-gene or one single-topology tract? [(see answer)](#q11)

* Repeat the simulations with different assumptions for the population size to see how these assumptions inluence the resulting lengths of c-genes and single-topology tracts.

There are some reasons why the lengths of c-genes and single-topology tracts may not be as short in practice as the results of c-genie may suggest. For example, undetected past population bottlenecks would reduce the amount of incomplete lineage sorting, which could extend the length of both types of fragments. In addition, the presence of "recombination deserts" ([Yu et al. 2001](https://www.nature.com/articles/35057185)) could lead to some very large c-genes and single-topology tracts. Nevertheless, it is important to be aware of the possible presence of recombination within the alignments used for phylogenetic inference. While the study of [Lanier and Knowles (2012)](https://academic.oup.com/sysbio/article/61/4/691/1637909) as well as preliminary analyses with c-genie suggest that within-alignment recombination may in fact not have a strong influence on the inference of the species-tree topology, the consequences for divergence-time estimates and downstream analyses of introgression are less clear and should be investigated in future studies.

<br><hr>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Answers

<a name="q1"></a>

* **Question 1:** You might have noticed that the file does not contain any missing data anymore, as shown in the text below. This is because the imputation that is part of phasing with BEAGLE does exactly that: it replaces missing data with "imputed" alleles that are estimated based on the alleles present in other samples. This approach may work well with population-level data for model species where a reference set of haplotypes is available (such a reference set can be passed to BEAGLE with the `ref=` option); however, the accuracy of the imputed alleles may be questioned when the imputation is applied to datasets comprising multiple species without a reference set.

		##fileformat=VCFv4.2
		##filedate=20180523
		##source="beagle.16May18.771.jar"
		##INFO=<ID=AF,Number=A,Type=Float,Description="Estimated ALT Allele Frequencies">
		##INFO=<ID=DR2,Number=1,Type=Float,Description="Dosage R-Squared: estimated squared correlation between estimated REF dose [P(RA) + 2*P(RR)] and true REF dose">
		##INFO=<ID=IMP,Number=0,Type=Flag,Description="Imputed marker">
		##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
		##FORMAT=<ID=DS,Number=A,Type=Float,Description="estimated ALT dose [P(RA) + P(AA)]">
		##FORMAT=<ID=GP,Number=G,Type=Float,Description="Estimated Genotype Probability">
		#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  IZA1    IZC5    AUE7    AXD5    JBD5    JBD6    JUH9    JUI1    LJC9    LJD1    KHA7    KHA9    IVE8    IVF1    JWH1    JWH2    JWG8    JWG9    JWH3    JWH4    JWH5    JWH6    ISA6    ISB3    ISA8    IYA4    KFD2    KFD4
		NC_031969       45158   .       A       C       .       PASS    .       GT      0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|1     0|0     0|1     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0
		NC_031969       58829   .       T       C       .       PASS    .       GT      1|1     1|1     1|1     1|1     1|0     1|1     1|1     1|1     1|1     1|1     1|0     1|0     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     0|1     1|1
		NC_031969       88364   .       T       G       .       PASS    .       GT      1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1
		NC_031969       88371   .       C       T       .       PASS    .       GT      1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1
		NC_031969       98367   .       T       A       .       PASS    .       GT      1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1
		NC_031969       98404   .       G       C       .       PASS    .       GT      0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     1|0     1|0     0|0     0|0     0|0     0|0     1|0     1|0     0|0     0|0     0|0     0|0     0|1     1|0     0|0     0|0
		NC_031969       124768  .       A       C       .       PASS    .       GT      0|0     0|0     0|0     0|0     1|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0
		NC_031969       141856  .       G       A       .       PASS    .       GT      1|1     0|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1
		NC_031969       141896  .       G       T       .       PASS    .       GT      0|0     0|0     1|0     1|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0
		NC_031969       141908  .       G       A       .       PASS    .       GT      1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1     1|1


<a name="q2"></a>

* **Question 2:** The script `extract_blocks.rb` should report on the command line that 493 alignment blocks were written while 7,114 were excluded due to a high proportion of missing data. Thus, we could have obtained a larger number of alignments if we had allowed a greater proportion of missing data; however, these additional blocks would have been less suitable for phylogenetic analysis. Alternatively, less strict filters for quality and depth could have been chosen in variant calling, which would have led to an overall lower proportion of missing data. This, however, could also have compromised the reliability of the resulting alignments. Of course, if we wouldn't be limited to the use of a single chromosome as in this tutorial, but would use data from across the whole genome, the number of suitable block alignments could be much larger. Nevertheless, it may be worthwhile to aim for a higher coverage and better quality already at the sequencing stage (here, an Illumina read coverage around 10&times; was used) to increase the proportion of the dataset that can ultimately be used for phylogenetic analyses.


<a name="q3"></a>

* **Question 3:** Executing the command `ls blocks/*.nex | wc -l` indicates that 238 block alignments remain in the `blocks` directory.


<a name="q4"></a>

* **Question 4:** The trio with the highest *D*-statistic can be identified with the following command:

		cat block_topology_frequencies.txt | tail -n +2 | sort -n -k 7 -r | head -n 1

	This should show that the trio of "altfas", "neocan", and "telvit" have a *D*-statistic of 0.842.



XXX

<a name="q11"></a>

* **Question 11:** Unfortunately, the mean lengths of c-genes and single-topology tracts are extremely short: between 13 and 26 bp. Consequently, the probability that a 50 kb alignment contains just one c-gene or single-topology tract is 0. Instead, alignments of this length contain on average around 3680 c-genes and about 1850 single-topology tracts. This means that if our assumptions for the species tree, the recombination rate, and the population size were correct, all the phylogenies inferred for block alignments in fact averaged over a large number of different topologies.